方案A（遍历）：
输入（生成<key,Item>映射，将key存入数组）：
allItemId = allInputsId = [a, b, c, d, e] （allInputsId用于结果展示）

穷举数组 allInputsId 的全部子集（最少2个元素）（优化：怎样快速排除实际完全一样的状况呢？）：
allSubsets = {key1: [a, b, c, d, e], [a, b, c, d], ...}

初始化数组 resultsId 用于存储结果。
对 allSubsets 中每一个数组：

- 尝试穷举每一种合成方案，对于方案中每一步：

  - 检查两侧物品，左侧为附魔书，右侧为物品时，无法合并，此方案作废。
  - 对于右侧物品，计算时去掉冲突魔咒（JE版导致等级+1）与等级低于左侧同名魔咒的魔咒，如因此导致右侧物品再无魔咒，无法合并，此方案作废。
  - 有魔咒等级超出原版上限，或当次操作需要的经验等级>=40时，无法合并，此方案作废。
  - 通过以上检测的，在数组 resultsId 里匹配相同魔咒列表的物品：
    - 有同名魔咒的等级不同时，保留等级更高的。
    - 所有同名魔咒等级均相同时，保留总消耗更低的。
  - 若 resultsId 里未发现有相同魔咒列表的物品，将此物品的 id 存入 resultsId。

输出 resultsId

方案B（搜索，深度优先？）：
约束条件：
- 每一步合并操作中，左侧为附魔书时，右侧为书以外的物品时，合并无法进行。
- 检查右侧物品。除去冲突魔咒（可设置关闭，JE还会导致步骤需求的经验等级+1）；除去与左侧物品同名且等级较低的魔咒。如因此导致右侧物品再无魔咒，合并无法进行。
- 有魔咒等级超出原版上限（可设置关闭），或当次操作需要的经验等级>=40（可设置关闭）时，合并无法进行。

计算步骤：
- 检查输入，物品数量>1时，清除无魔咒物品至只剩一个（用户界面给予"此物品不会被使用"提示）
- 将输入-初始状态（按一定规则重排，生成<key,Item>映射，将key存入数组）：
  - allItemId = allInputsId = [a0, a1, a2, a3, a4, ...]
- 在每一个子节点中，尝试合并数组里符合约束条件的两个物品，例 a0 与 a1 合成了 a*，则当前状态为 [a2, a3 ,a4 , ... , a*]，a* 中设置 usedItemId = [a0, a1]。
- 当存在一个节点，内部所有物品均无法合并时。在这个节点的状态数组中取 usedItemId 最长的物品作为结果之一。
